USE BDX
GO
DROP PROCEDURE IF EXISTS dbo.X_1
GO
CREATE PROCEDURE dbo.X_1
@X INT, --VARIABLES PARAMETROS
@VAR_TYPE_TABLE X_TYPE READONLY
AS
BEGIN
	DECLARE @ENTITY SMALLINT = 6 --ENTIDAD DEL LOG, PARA IDENTIFICAR QUE ENTIDAD COMO USUARIO, ORDEN DE COMPRA, ETC, SE HA UTILIZADO
	DECLARE @EVENTO SMALLINT = 1 --EN CURSO	
	DECLARE @EVENTO_ACEPTADO SMALLINT = 2 --ACEPTADO
	DECLARE @EVENTO_ERROR SMALLINT = 3 -- CANCELADO
	DECLARE @MSG_FINISH VARCHAR(120) = 'MENSAJE DE FINALIZACION'
	--LOG DE INICIO SE GENERA EN EL SERVICIOS DE LA API
	BEGIN TRY		
		BEGIN TRANSACTION;
	
			--CUERPO DEL PROCEDIMIENTO
			--VAN LAS VALIDACIONES TAMBIEN Y SE LLAMAN CON EXEC O LAS FUNCIONES
			--LAS VALIDACIONES GENERAN THROW
			--TAMBIEN SE PUEDEN USAR THROW 51000, 'MENSAJE', 1;
			
			
			--EJECUTAR EL PROCEDURE DE LOG	
			exec dbo.BO_CREATE_LOG_EQUIVALENCE @ENTITY, @EVENTO_ACEPTADO, @MSG_FINISH, @NUMERO_O_ID_DEL_PRINCIPAL_ENTIDAD				
		COMMIT TRANSACTION;		
	END TRY
	BEGIN CATCH
	--RECOLECTA LA INFORMACION Y LE HACE UN LOG Y SI EL ID DE LA TABLA O TABLAS QUE SEAN IDENTITY SE RESETEA AL ULTIMO VALOR
		ROLLBACK TRANSACTION;
		DECLARE @ERR VARCHAR(MAX), @PROCEDURE VARCHAR(MAX);

		DECLARE @UltimoID INT;
		SELECT @UltimoID = ISNULL(MAX(ID_IDENTITY), 0) FROM BD2..TB1;
		-- Restablecemos el valor de IDENTITY
        DBCC CHECKIDENT ('BDX..TB1', RESEED, @UltimoID);	

		select @ERR = ERROR_MESSAGE(), @PROCEDURE = ERROR_PROCEDURE();
		SET @ERR = @ERR + '; EN: ' + @PROCEDURE
		exec dbo.BO_CREATE_LOG_EQUIVALENCE @ENTITY, @EVENTO_ERROR, @ERR, @NUMERO_O_ID_DEL_PRINCIPAL_ENTIDAD;
		THROW;
	END CATCH
END